// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// TransactionSummary transaction summary
//
// swagger:model TransactionSummary
type TransactionSummary struct {

	// account id
	// Required: true
	// Format: uuid
	AccountID *strfmt.UUID `json:"account_id"`

	// The transaction amount in milliunits format
	// Required: true
	Amount *int64 `json:"amount"`

	// Whether or not the transaction is approved
	// Required: true
	Approved *bool `json:"approved"`

	// category id
	// Format: uuid
	CategoryID strfmt.UUID `json:"category_id,omitempty"`

	// The cleared status of the transaction
	// Required: true
	// Enum: [cleared uncleared reconciled]
	Cleared *string `json:"cleared"`

	// The transaction date in ISO format (e.g. 2016-12-01)
	// Required: true
	// Format: date
	Date *strfmt.Date `json:"date"`

	// If the transaction is a debt/loan account transaction, the type of transaction
	// Enum: [payment refund fee interest escrow balancedAdjustment credit charge]
	DebtTransactionType *string `json:"debt_transaction_type,omitempty"`

	// Whether or not the transaction has been deleted.  Deleted transactions will only be included in delta requests.
	// Required: true
	Deleted *bool `json:"deleted"`

	// The transaction flag
	// Enum: [red orange yellow green blue purple]
	FlagColor *string `json:"flag_color,omitempty"`

	// id
	// Required: true
	ID *string `json:"id"`

	// If the transaction was imported, this field is a unique (by account) import identifier.  If this transaction was imported through File Based Import or Direct Import and not through the API, the import_id will have the format: 'YNAB:[milliunit_amount]:[iso_date]:[occurrence]'.  For example, a transaction dated 2015-12-30 in the amount of -$294.23 USD would have an import_id of 'YNAB:-294230:2015-12-30:1'.  If a second transaction on the same account was imported and had the same date and same amount, its import_id would be 'YNAB:-294230:2015-12-30:2'.
	ImportID string `json:"import_id,omitempty"`

	// If the transaction was imported, the payee name that was used when importing and before applying any payee rename rules
	// Max Length: 200
	ImportPayeeName string `json:"import_payee_name,omitempty"`

	// If the transaction was imported, the original payee name as it appeared on the statement
	// Max Length: 200
	ImportPayeeNameOriginal string `json:"import_payee_name_original,omitempty"`

	// If transaction is matched, the id of the matched transaction
	MatchedTransactionID string `json:"matched_transaction_id,omitempty"`

	// memo
	Memo string `json:"memo,omitempty"`

	// payee id
	// Format: uuid
	PayeeID strfmt.UUID `json:"payee_id,omitempty"`

	// If a transfer transaction, the account to which it transfers
	// Format: uuid
	TransferAccountID strfmt.UUID `json:"transfer_account_id,omitempty"`

	// If a transfer transaction, the id of transaction on the other side of the transfer
	TransferTransactionID string `json:"transfer_transaction_id,omitempty"`
}

// Validate validates this transaction summary
func (m *TransactionSummary) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccountID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateApproved(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCategoryID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCleared(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDebtTransactionType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDeleted(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFlagColor(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateImportPayeeName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateImportPayeeNameOriginal(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePayeeID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransferAccountID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TransactionSummary) validateAccountID(formats strfmt.Registry) error {

	if err := validate.Required("account_id", "body", m.AccountID); err != nil {
		return err
	}

	if err := validate.FormatOf("account_id", "body", "uuid", m.AccountID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *TransactionSummary) validateAmount(formats strfmt.Registry) error {

	if err := validate.Required("amount", "body", m.Amount); err != nil {
		return err
	}

	return nil
}

func (m *TransactionSummary) validateApproved(formats strfmt.Registry) error {

	if err := validate.Required("approved", "body", m.Approved); err != nil {
		return err
	}

	return nil
}

func (m *TransactionSummary) validateCategoryID(formats strfmt.Registry) error {
	if swag.IsZero(m.CategoryID) { // not required
		return nil
	}

	if err := validate.FormatOf("category_id", "body", "uuid", m.CategoryID.String(), formats); err != nil {
		return err
	}

	return nil
}

var transactionSummaryTypeClearedPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["cleared","uncleared","reconciled"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		transactionSummaryTypeClearedPropEnum = append(transactionSummaryTypeClearedPropEnum, v)
	}
}

const (

	// TransactionSummaryClearedCleared captures enum value "cleared"
	TransactionSummaryClearedCleared string = "cleared"

	// TransactionSummaryClearedUncleared captures enum value "uncleared"
	TransactionSummaryClearedUncleared string = "uncleared"

	// TransactionSummaryClearedReconciled captures enum value "reconciled"
	TransactionSummaryClearedReconciled string = "reconciled"
)

// prop value enum
func (m *TransactionSummary) validateClearedEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, transactionSummaryTypeClearedPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TransactionSummary) validateCleared(formats strfmt.Registry) error {

	if err := validate.Required("cleared", "body", m.Cleared); err != nil {
		return err
	}

	// value enum
	if err := m.validateClearedEnum("cleared", "body", *m.Cleared); err != nil {
		return err
	}

	return nil
}

func (m *TransactionSummary) validateDate(formats strfmt.Registry) error {

	if err := validate.Required("date", "body", m.Date); err != nil {
		return err
	}

	if err := validate.FormatOf("date", "body", "date", m.Date.String(), formats); err != nil {
		return err
	}

	return nil
}

var transactionSummaryTypeDebtTransactionTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["payment","refund","fee","interest","escrow","balancedAdjustment","credit","charge"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		transactionSummaryTypeDebtTransactionTypePropEnum = append(transactionSummaryTypeDebtTransactionTypePropEnum, v)
	}
}

const (

	// TransactionSummaryDebtTransactionTypePayment captures enum value "payment"
	TransactionSummaryDebtTransactionTypePayment string = "payment"

	// TransactionSummaryDebtTransactionTypeRefund captures enum value "refund"
	TransactionSummaryDebtTransactionTypeRefund string = "refund"

	// TransactionSummaryDebtTransactionTypeFee captures enum value "fee"
	TransactionSummaryDebtTransactionTypeFee string = "fee"

	// TransactionSummaryDebtTransactionTypeInterest captures enum value "interest"
	TransactionSummaryDebtTransactionTypeInterest string = "interest"

	// TransactionSummaryDebtTransactionTypeEscrow captures enum value "escrow"
	TransactionSummaryDebtTransactionTypeEscrow string = "escrow"

	// TransactionSummaryDebtTransactionTypeBalancedAdjustment captures enum value "balancedAdjustment"
	TransactionSummaryDebtTransactionTypeBalancedAdjustment string = "balancedAdjustment"

	// TransactionSummaryDebtTransactionTypeCredit captures enum value "credit"
	TransactionSummaryDebtTransactionTypeCredit string = "credit"

	// TransactionSummaryDebtTransactionTypeCharge captures enum value "charge"
	TransactionSummaryDebtTransactionTypeCharge string = "charge"
)

// prop value enum
func (m *TransactionSummary) validateDebtTransactionTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, transactionSummaryTypeDebtTransactionTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TransactionSummary) validateDebtTransactionType(formats strfmt.Registry) error {
	if swag.IsZero(m.DebtTransactionType) { // not required
		return nil
	}

	// value enum
	if err := m.validateDebtTransactionTypeEnum("debt_transaction_type", "body", *m.DebtTransactionType); err != nil {
		return err
	}

	return nil
}

func (m *TransactionSummary) validateDeleted(formats strfmt.Registry) error {

	if err := validate.Required("deleted", "body", m.Deleted); err != nil {
		return err
	}

	return nil
}

var transactionSummaryTypeFlagColorPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["red","orange","yellow","green","blue","purple"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		transactionSummaryTypeFlagColorPropEnum = append(transactionSummaryTypeFlagColorPropEnum, v)
	}
}

const (

	// TransactionSummaryFlagColorRed captures enum value "red"
	TransactionSummaryFlagColorRed string = "red"

	// TransactionSummaryFlagColorOrange captures enum value "orange"
	TransactionSummaryFlagColorOrange string = "orange"

	// TransactionSummaryFlagColorYellow captures enum value "yellow"
	TransactionSummaryFlagColorYellow string = "yellow"

	// TransactionSummaryFlagColorGreen captures enum value "green"
	TransactionSummaryFlagColorGreen string = "green"

	// TransactionSummaryFlagColorBlue captures enum value "blue"
	TransactionSummaryFlagColorBlue string = "blue"

	// TransactionSummaryFlagColorPurple captures enum value "purple"
	TransactionSummaryFlagColorPurple string = "purple"
)

// prop value enum
func (m *TransactionSummary) validateFlagColorEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, transactionSummaryTypeFlagColorPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TransactionSummary) validateFlagColor(formats strfmt.Registry) error {
	if swag.IsZero(m.FlagColor) { // not required
		return nil
	}

	// value enum
	if err := m.validateFlagColorEnum("flag_color", "body", *m.FlagColor); err != nil {
		return err
	}

	return nil
}

func (m *TransactionSummary) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

func (m *TransactionSummary) validateImportPayeeName(formats strfmt.Registry) error {
	if swag.IsZero(m.ImportPayeeName) { // not required
		return nil
	}

	if err := validate.MaxLength("import_payee_name", "body", m.ImportPayeeName, 200); err != nil {
		return err
	}

	return nil
}

func (m *TransactionSummary) validateImportPayeeNameOriginal(formats strfmt.Registry) error {
	if swag.IsZero(m.ImportPayeeNameOriginal) { // not required
		return nil
	}

	if err := validate.MaxLength("import_payee_name_original", "body", m.ImportPayeeNameOriginal, 200); err != nil {
		return err
	}

	return nil
}

func (m *TransactionSummary) validatePayeeID(formats strfmt.Registry) error {
	if swag.IsZero(m.PayeeID) { // not required
		return nil
	}

	if err := validate.FormatOf("payee_id", "body", "uuid", m.PayeeID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *TransactionSummary) validateTransferAccountID(formats strfmt.Registry) error {
	if swag.IsZero(m.TransferAccountID) { // not required
		return nil
	}

	if err := validate.FormatOf("transfer_account_id", "body", "uuid", m.TransferAccountID.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this transaction summary based on context it is used
func (m *TransactionSummary) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TransactionSummary) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TransactionSummary) UnmarshalBinary(b []byte) error {
	var res TransactionSummary
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
