// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Account account
//
// swagger:model Account
type Account struct {

	// The current balance of the account in milliunits format
	// Required: true
	Balance *int64 `json:"balance"`

	// The current cleared balance of the account in milliunits format
	// Required: true
	ClearedBalance *int64 `json:"cleared_balance"`

	// Whether this account is closed or not
	// Required: true
	Closed *bool `json:"closed"`

	// The escrow value(s) for the debt/loan account, by effective date.  The amounts are specified in milliunits format.
	DebtEscrowAmounts LoanAccountPeriodicValue `json:"debt_escrow_amounts,omitempty"`

	// The debt/loan account interest rate(s), by effective date.
	DebtInterestRates LoanAccountPeriodicValue `json:"debt_interest_rates,omitempty"`

	// The minimum payment amount(s) for the debt/loan account, by effective date.  The amounts are specified in milliunits format.
	DebtMinimumPayments LoanAccountPeriodicValue `json:"debt_minimum_payments,omitempty"`

	// The original debt/loan account balance, specified in milliunits format.
	DebtOriginalBalance int64 `json:"debt_original_balance,omitempty"`

	// Whether or not the account has been deleted.  Deleted accounts will only be included in delta requests.
	// Required: true
	Deleted *bool `json:"deleted"`

	// If an account linked to a financial institution (direct_import_linked=true) and the linked connection is not in a healthy state, this will be true.
	DirectImportInError bool `json:"direct_import_in_error,omitempty"`

	// Whether or not the account is linked to a financial institution for automatic transaction import.
	DirectImportLinked bool `json:"direct_import_linked,omitempty"`

	// id
	// Required: true
	// Format: uuid
	ID *strfmt.UUID `json:"id"`

	// A date/time specifying when the account was last reconciled.
	// Format: date-time
	LastReconciledAt strfmt.DateTime `json:"last_reconciled_at,omitempty"`

	// name
	// Required: true
	Name *string `json:"name"`

	// note
	Note string `json:"note,omitempty"`

	// Whether this account is on budget or not
	// Required: true
	OnBudget *bool `json:"on_budget"`

	// The payee id which should be used when transferring to this account
	// Required: true
	// Format: uuid
	TransferPayeeID *strfmt.UUID `json:"transfer_payee_id"`

	// type
	// Required: true
	Type *AccountType `json:"type"`

	// The current uncleared balance of the account in milliunits format
	// Required: true
	UnclearedBalance *int64 `json:"uncleared_balance"`
}

// Validate validates this account
func (m *Account) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBalance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClearedBalance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClosed(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDebtEscrowAmounts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDebtInterestRates(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDebtMinimumPayments(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDeleted(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastReconciledAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOnBudget(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransferPayeeID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUnclearedBalance(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Account) validateBalance(formats strfmt.Registry) error {

	if err := validate.Required("balance", "body", m.Balance); err != nil {
		return err
	}

	return nil
}

func (m *Account) validateClearedBalance(formats strfmt.Registry) error {

	if err := validate.Required("cleared_balance", "body", m.ClearedBalance); err != nil {
		return err
	}

	return nil
}

func (m *Account) validateClosed(formats strfmt.Registry) error {

	if err := validate.Required("closed", "body", m.Closed); err != nil {
		return err
	}

	return nil
}

func (m *Account) validateDebtEscrowAmounts(formats strfmt.Registry) error {
	if swag.IsZero(m.DebtEscrowAmounts) { // not required
		return nil
	}

	if m.DebtEscrowAmounts != nil {
		if err := m.DebtEscrowAmounts.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("debt_escrow_amounts")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("debt_escrow_amounts")
			}
			return err
		}
	}

	return nil
}

func (m *Account) validateDebtInterestRates(formats strfmt.Registry) error {
	if swag.IsZero(m.DebtInterestRates) { // not required
		return nil
	}

	if m.DebtInterestRates != nil {
		if err := m.DebtInterestRates.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("debt_interest_rates")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("debt_interest_rates")
			}
			return err
		}
	}

	return nil
}

func (m *Account) validateDebtMinimumPayments(formats strfmt.Registry) error {
	if swag.IsZero(m.DebtMinimumPayments) { // not required
		return nil
	}

	if m.DebtMinimumPayments != nil {
		if err := m.DebtMinimumPayments.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("debt_minimum_payments")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("debt_minimum_payments")
			}
			return err
		}
	}

	return nil
}

func (m *Account) validateDeleted(formats strfmt.Registry) error {

	if err := validate.Required("deleted", "body", m.Deleted); err != nil {
		return err
	}

	return nil
}

func (m *Account) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	if err := validate.FormatOf("id", "body", "uuid", m.ID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Account) validateLastReconciledAt(formats strfmt.Registry) error {
	if swag.IsZero(m.LastReconciledAt) { // not required
		return nil
	}

	if err := validate.FormatOf("last_reconciled_at", "body", "date-time", m.LastReconciledAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Account) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *Account) validateOnBudget(formats strfmt.Registry) error {

	if err := validate.Required("on_budget", "body", m.OnBudget); err != nil {
		return err
	}

	return nil
}

func (m *Account) validateTransferPayeeID(formats strfmt.Registry) error {

	if err := validate.Required("transfer_payee_id", "body", m.TransferPayeeID); err != nil {
		return err
	}

	if err := validate.FormatOf("transfer_payee_id", "body", "uuid", m.TransferPayeeID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Account) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	if m.Type != nil {
		if err := m.Type.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("type")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("type")
			}
			return err
		}
	}

	return nil
}

func (m *Account) validateUnclearedBalance(formats strfmt.Registry) error {

	if err := validate.Required("uncleared_balance", "body", m.UnclearedBalance); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this account based on the context it is used
func (m *Account) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDebtEscrowAmounts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDebtInterestRates(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDebtMinimumPayments(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Account) contextValidateDebtEscrowAmounts(ctx context.Context, formats strfmt.Registry) error {

	if err := m.DebtEscrowAmounts.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("debt_escrow_amounts")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("debt_escrow_amounts")
		}
		return err
	}

	return nil
}

func (m *Account) contextValidateDebtInterestRates(ctx context.Context, formats strfmt.Registry) error {

	if err := m.DebtInterestRates.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("debt_interest_rates")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("debt_interest_rates")
		}
		return err
	}

	return nil
}

func (m *Account) contextValidateDebtMinimumPayments(ctx context.Context, formats strfmt.Registry) error {

	if err := m.DebtMinimumPayments.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("debt_minimum_payments")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("debt_minimum_payments")
		}
		return err
	}

	return nil
}

func (m *Account) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if m.Type != nil {
		if err := m.Type.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("type")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("type")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Account) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Account) UnmarshalBinary(b []byte) error {
	var res Account
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
